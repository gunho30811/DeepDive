ECMAScript는 자바스크립트 표준 사양인 ECMA-262를 말하며, 프로그래밍 언어의 값, 타입, 객체와 프로퍼티, 함수,
표준 빌트인 객체등 핵심 문법 규정. 브라우저에는 내장되는 자바스크립트 엔진이 구현되어 있다.

자바스크립트는 문법은 C, 자바와 유사하고 *셀프에서는 프로토타입 기반 상속을, *스킴에서는 일급함수의 개념을 차용했다.
자바스크립트는 개발자가 컴파일 작업을 수행하지 않는 인터프리터 언어이다.
모던 자바스크립트 엔진은 인터프리터와 컴파일러의 장점을 결합해 비교적 처리 속도가 느린 인터프리터의 단점을
해결했다. 인터프리터는 소스코드를 즉시 실행하고 컴파일러는 빠르게 동작하는 머신 코드를 생성하고 최적화하는
방식으로 단점을 해결했다. 이를 통해 컴파일 단계에서 추가적인 시간이 필요함에도 빠르게 코드를 실행 할 수 있다.
이를 통해 인터프리터 언어의 장점인 동적 기능 지원을 살리면서 실행 속도가 느리다는 단점을 극복했다. 현재는
조금 모호재겨 가는 추세지만, 실행파일이 생성되지 않고 인터프리터의 도움 없이 실행 할 수 없기 때문에 컴파일러 언
어라고 볼 수는 없다.

*자바스크립트는 명령형, 함수형, 프로토타입 기반의 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어이다.

컴파일러 언어: 코드가 실행되기 전 단계인 컴파일 타임에 소스코드 전체를 한 번에 머신코드로 변환 후 실행.
-실행 파일을 가지고 있어, 컴파일과 실행 단계가 분리 되어 코드 실행 속도가 빠르다.
인터프리터 언어: 코드가 실행되는 단계인 런타임에 문 단위로 한 줄씩 중간인 바이트코드로 변환 후 실행.
-코드가 실행 될 적 마다, 인터프리터 과정이 반복 수행 되므로 실행속도가 비교적 느리다. 

모든 브라우저는 자바스크립트 엔진을 내장하고 있다. 뿐 아니라, Node.js도 가지고 있다. 다만, 브라우저에서 
실행하는 자바스크립트와 Node.js에서 실행하는 자바스크립트의 쓰임이 다르다.
브라우저는 -> 렌더링
Node.js -> 브라우저 외부에서 자바스크립트 실행 환경을 제공하는 것이 주된 목적이다.
따라서 브라우저와 Node.js는 자바스크립트의 코어인 ECMAScirpt 는 실행 할 수 있으나, 브라우저와 Node.js에 각 각
추가되는 기능은 호환되지 않는다.
예시로, 브라우저는 파싱된 HTML 요소를 선택 조작 하는 DOM API를 제공한다. 하지만 Node.js는 DOM API가 없다.
반대로 Node.js에서는 파일을 생성하고 수정할 수 있는 파일 시스템을 제공 한다. 하지만 브라우저는 지원하지 않는다.
(다만, Web API인 FileReader 객체 를 사용해 파일을 읽는 것은 가능하다.)

디버깅 (글로 설명이 어려워서 아래 링크를 참고하자)
-https://developer.chrome.com/docs/devtools/open/
> 들어가서 필요한 정보를 찾으면 된다.

npm은 자바스크립트 패키지 매니저이다. Node.js에서 사용할 수 있는 모듈들을 패키지화해서 모아둔 저장소 역할과
패키지 설치 및 관리를 위한 CLI를 제공한다. (모듈화)

변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름.

변수 선언에는 var, let, const 키워드 사용.
var 단점 -> 블록 레벨 스코프를 지원하지 않고, 함수 레벨 스코프를 지원 한다 는 것. 이로 인해 의도치 않게 전역 변수가
선언되어 심각한 부작용이 발생하기도 함.

undefined
-변수를 선언한 이후, 아직 변수에 값을 할당하지 않은 상태에서 나오는 값.

자바스크립트 엔진은 변수 선언을 2단계에 거쳐 수행한다.
-선언단계: 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.
-초기화 단계: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화 한다.

변수 선언의 실행 시점과 변수 호이스팅
-JS는 인터프리터에 의해 한 줄 씩 순차로 실행된다, 하지만 
console.log(score);
var score; 
은 ReferenceError가 아닌 undefined가 발생한다. 그 이유는 변수 선언이 런타인 이전 단계에서 먼저 실행되기 때문이다.
이처럼 변수 선언문이 코드의 선두로 끌어 올려진 것 처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅이라 한다.
(var, let, const, function, function*, class 키워드를 사용해서 선언하는 모든 식별자는 호이스팅된다.)

값의 할당
-변수에 값을 할당 할 때는 할당 연산자 =를 사용.
-변수 선언과 할당은 실행 시점이 다르다.
-변수 선언은 소스코드가 순차적으로 실행되는 시점 런타임 이전에 실행된다. 하지만
-값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.
-런타임 이전의 undefined가 저장되어있는 메모리 공간 주소와 , 런타임시점에 값의 할당된 메모리 공간 주소는 다르다
-런타임 시점에서 변수에 새롭게 메모리 공간 주소를 변경하고 값을 할당 하는 것이다.
-식별자가 연결되지 않은 메모리 공간은 이제 가비지콜렉터 기능에 의해 메모리 해제가 된다.
-가비지 콜렉터란 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하며 사용되지 않는 메모리를 해제하는 기능을 말함.

언매니지드언어 VS 매니지드 언어 -> 메모리 공간을 관리할 수 있는 C언어, 자동 관리하는 JS(가비지 콜렉터)

네이밍 컨벤션 시 (식별자 이름 짓는법) -> var firstName; //카멜 케이스 , var FirstName;//파스칼 케이스 
생성자 함수, 클래스 이름에는 파스칼 케이스를 , 변수나 함수의 이름에는 카멜케이스를 사용한다.

5장
값: 표현식이 평가 되어 생성된 결과.
리터럴: 사람이 이해 할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법 (리터럴도 표현식)
표현식: 값으로 평가될 수 있는 문.
문: 프로그램을 구성하는 기본단위이자 최소 실행 단위.
문은->선언문,(할당문=표현식),조건문,반목문 등으로 구분 
표현식인 문과 표현식이 아닌 문을 구별하는 방법은 변수에 할당 해보는 것.
토큰:문법적인 의미를 가지며 문법적으로 더이상 나눌 수 없는 코드의 기본 요소를 의미.
